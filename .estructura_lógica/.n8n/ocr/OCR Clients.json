{
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Split Images Generic - VERSION CLIENTES\n// Crear items genéricos sin asumir tipo de imagen\n// REQUIERE user_id obligatorio (clientes autenticados)\n\nconst items = [];\nconst inputItem = $input.all()[0];\n\n// ============================================\n// 1. EXTRACCIÓN DE user_id (OBLIGATORIO)\n// ============================================\nlet userId = null;\n\n// Buscar en body (FormData)\nif (inputItem.json.body && inputItem.json.body.user_id) {\n  userId = inputItem.json.body.user_id;\n} else if (inputItem.json.body && inputItem.json.body.userId) {\n  userId = inputItem.json.body.userId;\n} else if (inputItem.json.body && inputItem.json.body.usuario_id) {\n  userId = inputItem.json.body.usuario_id;\n}\n\n// Buscar en json directo\nif (!userId && inputItem.json.user_id) {\n  userId = inputItem.json.user_id;\n} else if (!userId && inputItem.json.userId) {\n  userId = inputItem.json.userId;\n} else if (!userId && inputItem.json.usuario_id) {\n  userId = inputItem.json.usuario_id;\n}\n\n// Buscar en query parameters\nif (!userId && inputItem.json.query) {\n  userId = inputItem.json.query.user_id;\n}\n\n// Buscar en headers\nif (!userId && inputItem.json.headers && inputItem.json.headers['user-id']) {\n  userId = inputItem.json.headers['user-id'];\n}\n\nconsole.log('Debug - Input item:', JSON.stringify(inputItem.json, null, 2));\nconsole.log('Debug - Found user_id:', userId);\n\n// VALIDACIÓN CRÍTICA: user_id es OBLIGATORIO para clientes\nif (!userId) {\n  throw new Error('user_id is required for client workflow - received: ' + JSON.stringify(inputItem.json));\n}\n\n// ============================================\n// 2. EXTRACCIÓN DE DATOS DEL PROYECTO\n// ============================================\nconst projectTitle = (inputItem.json.body && inputItem.json.body.project_title) \n  || inputItem.json.project_title \n  || 'Proyecto Solar';\n\nconst projectDescription = (inputItem.json.body && inputItem.json.body.project_description) \n  || inputItem.json.project_description \n  || '';\n\nconsole.log('Debug - Project title:', projectTitle);\nconsole.log('Debug - Project description:', projectDescription);\n\n// ============================================\n// 3. PROCESAMIENTO DE IMÁGENES\n// ============================================\nconst binaryKeys = Object.keys(inputItem.binary || {});\n\nif (binaryKeys.length === 0) {\n  throw new Error('No se recibieron imágenes en la solicitud');\n}\n\nconsole.log('Debug - Found binary images:', binaryKeys.length);\n\n// Crear un item por cada imagen recibida\nbinaryKeys.forEach((key, index) => {\n  items.push({\n    json: { \n      user_id: userId,                    // CRÍTICO: user_id en lugar de temp_lead_id\n      project_title: projectTitle,         // Datos del proyecto\n      project_description: projectDescription,\n      index: index,\n      total_images: binaryKeys.length\n    },\n    binary: { \n      [`imagen_${index + 1}`]: inputItem.binary[key] \n    }\n  });\n});\n\nconsole.log('Debug - Created items:', items.length);\nconsole.log('Debug - Items with user_id:', items.map(i => ({ user_id: i.json.user_id, index: i.json.index })));\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        876
      ],
      "id": "35b819e6-3665-4af5-9158-9c7ec39fe15c",
      "name": "Split Images Generic"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{ $json.index }}",
        "looseTypeValidation": true
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -912,
        876
      ],
      "id": "38ee7c75-e5b1-4daa-a694-ed7a37f12f26",
      "name": "Route by Index"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/files",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "purpose",
              "value": "ocr"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "imagen_2"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -688,
        972
      ],
      "id": "db36c73f-3990-42e0-bedb-f561b46abc66",
      "name": "Upload Image 2",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/ocr",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"mistral-ocr-latest\",\n  \"document\": {\n    \"type\": \"document_url\",\n    \"document_url\": \"{{ $json.url }}\"\n  },\n  \"include_image_base64\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -240,
        972
      ],
      "id": "3411e7e5-1e00-460b-8eb0-eacd3c723551",
      "name": "OCR Generic 2",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -16,
        876
      ],
      "id": "54f58d80-e638-43e0-824d-1dfaa2777fc2",
      "name": "Merge OCR Results"
    },
    {
      "parameters": {
        "jsCode": "// Clasificador inteligente basado en contenido extraido\nconst items = $input.all();\n\n// Extraer el texto OCR de ambas imagenes\nconst ocr1 = items[0].json.pages?.[0]?.markdown || '';\nconst ocr2 = items[1].json.pages?.[0]?.markdown || '';\n\n// Funcion para detectar si es frontal (datos del cliente)\nfunction isFrontal(text) {\n  const frontalIndicators = [\n    /NO\\.?\\s*DE\\s*SERVICIO/i,\n    /RMU\\s*:/i,\n    /CUENTA\\s*:/i,\n    /CFE\\s*CUENTA/i,\n    /TARIFA\\s*:/i,\n    /NO\\.?\\s*MEDIDOR/i,\n    /MULTIPLICADOR/i,\n    /NOMBRE\\s*:/i,\n    /DIRECCION\\s*:/i,\n    /TOTAL\\s+A\\s+PAGAR/i,\n    /AVISO\\s+RECIBO/i\n  ];\n  \n  let score = 0;\n  for (const pattern of frontalIndicators) {\n    if (pattern.test(text)) score++;\n  }\n  return score;\n}\n\n// Funcion para detectar si es posterior (tabla de consumos)\nfunction isPosterior(text) {\n  const posteriorIndicators = [\n    /CONSUMO\\s+HISTORICO/i,\n    /kWh.*PERIODO/i,\n    /HISTORICO\\s+DE\\s+CONSUMO/i,\n    /CONSUMOS\\s+MENSUALES/i,\n    /del\\s+\\d+\\s+\\w+\\s+\\d+\\s+al\\s+\\d+\\s+\\w+\\s+\\d+/i\n  ];\n  \n  // Contar patrones de fechas y numeros tipicos de tabla\n  const hasDateRanges = (text.match(/del\\s+\\d+\\s+\\w+\\s+\\d+\\s+al/gi) || []).length > 3;\n  const hasKwhNumbers = (text.match(/\\d{2,4}\\s*kWh/gi) || []).length > 3;\n  \n  let score = 0;\n  for (const pattern of posteriorIndicators) {\n    if (pattern.test(text)) score += 2;\n  }\n  if (hasDateRanges) score += 3;\n  if (hasKwhNumbers) score += 3;\n  \n  return score;\n}\n\n// Clasificar\nconst score1_frontal = isFrontal(ocr1);\nconst score1_posterior = isPosterior(ocr1);\nconst score2_frontal = isFrontal(ocr2);\nconst score2_posterior = isPosterior(ocr2);\n\nconsole.log('Scores:', {\n  image1: { frontal: score1_frontal, posterior: score1_posterior },\n  image2: { frontal: score2_frontal, posterior: score2_posterior }\n});\n\nlet frontalOcr, posteriorOcr;\n\nif (score1_frontal > score1_posterior && score2_posterior > score2_frontal) {\n  // Imagen 1 es frontal, Imagen 2 es posterior\n  frontalOcr = items[0].json;\n  posteriorOcr = items[1].json;\n} else if (score2_frontal > score2_posterior && score1_posterior > score1_frontal) {\n  // Imagen 2 es frontal, Imagen 1 es posterior\n  frontalOcr = items[1].json;\n  posteriorOcr = items[0].json;\n} else if (score1_frontal >= score2_frontal) {\n  // Por eliminacion, asignar imagen 1 como frontal\n  frontalOcr = items[0].json;\n  posteriorOcr = items[1].json;\n} else {\n  // Por eliminacion, asignar imagen 2 como frontal\n  frontalOcr = items[1].json;\n  posteriorOcr = items[0].json;\n}\n\n// Retornar items clasificados correctamente\nreturn [\n  {\n    json: {\n      ...frontalOcr,\n      type: 'frontal',\n      temp_lead_id: items[0].json.temp_lead_id\n    }\n  },\n  {\n    json: {\n      ...posteriorOcr,\n      type: 'posterior',\n      temp_lead_id: items[0].json.temp_lead_id\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        876
      ],
      "id": "347bd2fd-db17-4f57-8bd5-8a59aec4f8e1",
      "name": "Content Classifier"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.type }}",
              "rightValue": "frontal",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        432,
        876
      ],
      "id": "b89afbd3-b540-4309-a5f9-6eac7e98d582",
      "name": "Route by Type"
    },
    {
      "parameters": {
        "jsCode": "// Combine Data - VERSION CLIENTES\n// Combina datos de imágenes procesadas (frontal + posterior)\n// Propaga user_id y datos del proyecto\n\nconst frontal = $input.all()[0].json.output || $input.all()[0].json;\nconst posterior = $input.all()[1].json.output || $input.all()[1].json;\n\n// Extraer user_id y datos del proyecto del primer item\nconst userId = $input.all()[0].json.user_id;\nconst projectTitle = $input.all()[0].json.project_title || 'Proyecto Solar';\nconst projectDescription = $input.all()[0].json.project_description || '';\n\n// VALIDACIÓN CRÍTICA: user_id debe existir en clientes\nif (!userId) {\n  throw new Error('user_id is required in Combine Data node - workflow integrity error');\n}\n\nconsole.log('Debug - Combining data for user_id:', userId);\nconsole.log('Debug - Project title:', projectTitle);\n\nreturn [{\n  json: {\n    ...frontal,\n    ...posterior,\n    user_id: userId,                      // CRÍTICO: user_id en lugar de temp_lead_id\n    project_title: projectTitle,\n    project_description: projectDescription\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        876
      ],
      "id": "469e88f9-4c18-4b67-9d16-4f4916e88433",
      "name": "Combine Data"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://maps.googleapis.com/maps/api/geocode/json",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "address",
              "value": "={{ $json.direccion_formatted }}"
            },
            {
              "name": "key",
              "value": "AIzaSyBI6Vup5IKvfvlyvdhV_9nipF5FXaVnZ04"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1680,
        948
      ],
      "id": "6bf7838c-24ff-42b3-9169-bddf9c612f4d",
      "name": "Google Geocoding API"
    },
    {
      "parameters": {
        "jsCode": "const geocodeResult = $input.all()[0].json;\n\nif (geocodeResult.results && geocodeResult.results.length > 0) {\n  const location = geocodeResult.results[0].geometry.location;\n  return [{\n    json: {\n      ...($node[\"Combine Data\"].json),\n      latitud: location.lat,\n      longitud: location.lng,\n      direccion_geocoded: geocodeResult.results[0].formatted_address\n    }\n  }];\n} else {\n  return [{\n    json: {\n      ...($node[\"Combine Data\"].json),\n      latitud: 19.0414,\n      longitud: -98.2063,\n      direccion_geocoded: \"Puebla, Mexico (default)\"\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1904,
        948
      ],
      "id": "f85bb9e2-e82a-4ec1-8a94-c7ed5c54a534",
      "name": "Process Geocoding"
    },
    {
      "parameters": {
        "jsCode": "// Leer input\nconst data = $input.all()[0].json;\n\n// Parámetros del sistema\nconst PR = 0.80;\nconst oversizeFact = 1.05;\nconst DAYS_PER_MONTH = 30.4;\nconst panelWp = 550;\n\n// Inputs principales\nconst consumoMax = data.consumo_max || 250;\nconst irrDayAvg = parseFloat(data.nasa_irradiation?.annual_average) || 5.5;\n\n// Cálculos intermedios - Rendimientos específicos\nconst specYieldDay = irrDayAvg * PR;\nconst specYieldMonth = specYieldDay * DAYS_PER_MONTH;\nconst specYieldAnnual = specYieldDay * 365;\n\n// Cálculos intermedios - Potencia requerida (método dual)\nconst consumoAnual = consumoMax * 12;\nconst kWpByYear = consumoAnual / specYieldAnnual;\nconst kWpByPeak = consumoMax / specYieldMonth;\nconst kWpNeededRaw = Math.max(kWpByYear, kWpByPeak);\nconst kWpNeeded = kWpNeededRaw * oversizeFact;\n\n// Cálculos de paneles\nconst nPanels = Math.ceil((kWpNeeded * 1000) / panelWp);\n\n// Producción anual\nconst produccionAnual = specYieldAnnual * kWpNeeded;\n\nreturn [{\n  json: {\n    ...data,\n    sizing_results: {\n      // === INPUTS ===\n      inputs: {\n        consumo_max_kwh: consumoMax,\n        irradiacion_promedio_kwh_m2_dia: irrDayAvg,\n        performance_ratio: PR,\n        factor_sobredimensionamiento: oversizeFact,\n        dias_por_mes: DAYS_PER_MONTH,\n        potencia_panel_wp: panelWp\n      },\n      \n      // === CÁLCULOS INTERMEDIOS ===\n      calculos_intermedios: {\n        rendimiento_especifico_diario: +specYieldDay.toFixed(2),\n        rendimiento_especifico_mensual: +specYieldMonth.toFixed(2),\n        rendimiento_especifico_anual: +specYieldAnnual.toFixed(2),\n        consumo_anual_kwh: consumoAnual,\n        kWp_por_metodo_anual: +kWpByYear.toFixed(2),\n        kWp_por_metodo_mensual: +kWpByPeak.toFixed(2),\n        kWp_necesario_sin_oversize: +kWpNeededRaw.toFixed(2)\n      },\n      \n      // === RESULTADOS FINALES ===\n      sistema: {\n        capacidad_sistema_kw: +kWpNeeded.toFixed(2),\n        numero_paneles: nPanels,\n        produccion_anual_kwh: Math.round(produccionAnual)\n      }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4368,
        852
      ],
      "id": "ac1b1128-76d0-4baa-a17c-e19d43a076c8",
      "name": "Solar Sizing Calculator"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-3-haiku-20240307",
          "mode": "list",
          "cachedResultName": "Claude Haiku 3"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        728,
        848
      ],
      "id": "217a6fa4-6d60-477a-a49d-ca6b3e53b270",
      "name": "Anthropic Chat Model2",
      "credentials": {
        "anthropicApi": {
          "id": "CoNkmjeMGzkDNaXN",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "number": [
            {
              "name": "latitude",
              "value": "={{ $json.latitud }}"
            },
            {
              "name": "longitude",
              "value": "={{ $json.longitud }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Set Location Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        2128,
        948
      ],
      "id": "fdc25dc9-d8cd-4d13-9e2c-af2d20dc6b49",
      "notes": "INSERTAR DESPUÉS DE 'Process Geocoding'"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id,\n  datos_nasa_mensuales,\n  irradiacion_promedio_min,\n  irradiacion_promedio_max,\n  irradiacion_promedio_anual,\n  fecha_obtencion,\n  vigente_hasta,\n  hash_ubicacion\nFROM irradiacion_cache \nWHERE hash_ubicacion = '{{ $json.hash_ubicacion }}'\n  AND vigente_hasta > NOW()\nORDER BY created_at DESC \nLIMIT 1;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2576,
        948
      ],
      "id": "634143fd-deb8-46bb-9017-d188a062250e",
      "name": "Query NASA Cache",
      "alwaysOutputData": true,
      "executeOnce": false,
      "credentials": {
        "postgres": {
          "id": "jjHxTq8OTwLBl895",
          "name": "Postgres account supabase enerbook"
        }
      },
      "notes": "Busca en caché si ya existe irradiación para esta ubicación"
    },
    {
      "parameters": {
        "functionCode": "const data = $json?.properties?.parameter?.ALLSKY_SFC_SW_DWN ?? {};\nconst keys = Object.keys(data);\n\nif (keys.length === 0) {\n  return {\n    datos_nasa_mensuales: {\n      irradiacion_promedio: [],\n      unidad_medida: \"kWh/m²/día\",\n      resumen: {\n        mejor_mes: null,\n        peor_mes: null\n      }\n    },\n    irradiacion_promedio_min: null,\n    irradiacion_promedio_max: null,\n    irradiacion_promedio_anual: null\n  };\n}\n\n// Mapeo de meses con orden para mantener secuencia correcta\nconst monthsMap = [\n  { numero: \"01\", nombre: \"Enero\",      orden: 1 },\n  { numero: \"02\", nombre: \"Febrero\",    orden: 2 },\n  { numero: \"03\", nombre: \"Marzo\",      orden: 3 },\n  { numero: \"04\", nombre: \"Abril\",      orden: 4 },\n  { numero: \"05\", nombre: \"Mayo\",       orden: 5 },\n  { numero: \"06\", nombre: \"Junio\",      orden: 6 },\n  { numero: \"07\", nombre: \"Julio\",      orden: 7 },\n  { numero: \"08\", nombre: \"Agosto\",     orden: 8 },\n  { numero: \"09\", nombre: \"Septiembre\", orden: 9 },\n  { numero: \"10\", nombre: \"Octubre\",    orden: 10 },\n  { numero: \"11\", nombre: \"Noviembre\",  orden: 11 },\n  { numero: \"12\", nombre: \"Diciembre\",  orden: 12 }\n];\n\n// Acumuladores\nconst sumPerMonth = {};\nconst countPerMonth = {};\nlet totalSum = 0;\nlet totalCount = 0;\n\n// Procesar datos - excluir mes 13 (promedios anuales)\nfor (const k of keys) {\n  const v = +data[k];\n  if (!Number.isFinite(v)) continue;\n  \n  const month = k.slice(4, 6); // YYYYMM...\n  \n  // Saltar mes 13 (promedios anuales en los datos originales)\n  if (month === \"13\") continue;\n  \n  if (!sumPerMonth[month]) {\n    sumPerMonth[month] = 0;\n    countPerMonth[month] = 0;\n  }\n  \n  sumPerMonth[month] += v;\n  countPerMonth[month] += 1;\n  totalSum += v;\n  totalCount += 1;\n}\n\n// Calcular promedio anual\nconst promedioAnual = totalCount > 0 ? +(totalSum / totalCount).toFixed(2) : null;\n\n// Crear array de irradiación promedio (ordenado por mes)\nconst irradiacionPromedio = monthsMap\n  .filter(m => m.numero in sumPerMonth) // Solo meses con datos\n  .map(m => {\n    const avg = sumPerMonth[m.numero] / countPerMonth[m.numero];\n    return {\n      mes: m.nombre,\n      irradiacion: +avg.toFixed(2),\n      orden: m.orden,\n      mes_numero: m.numero\n    };\n  })\n  .sort((a, b) => a.orden - b.orden); // Ordenar por mes natural\n\n// Calcular min y max de los promedios mensuales\nconst irradiacionValues = irradiacionPromedio.map(x => x.irradiacion);\nconst minIrradiacion = irradiacionValues.length > 0 ? Math.min(...irradiacionValues) : null;\nconst maxIrradiacion = irradiacionValues.length > 0 ? Math.max(...irradiacionValues) : null;\n\n// Estructura para datos_nasa_mensuales (JSONB) - formato simplificado\nconst datosNasaMensuales = {\n  irradiacion_promedio: irradiacionPromedio,\n  unidad_medida: \"kWh/m²/día\",\n  resumen: {\n    mejor_mes: irradiacionPromedio.length > 0 \n      ? irradiacionPromedio.reduce((max, curr) => \n          curr.irradiacion > max.irradiacion ? curr : max\n        ).mes \n      : null,\n    peor_mes: irradiacionPromedio.length > 0 \n      ? irradiacionPromedio.reduce((min, curr) => \n          curr.irradiacion < min.irradiacion ? curr : min\n        ).mes \n      : null\n  }\n};\n\n// Retornar objeto con los campos exactos para la base de datos\nreturn {\n  datos_nasa_mensuales: datosNasaMensuales,\n  irradiacion_promedio_min: minIrradiacion,\n  irradiacion_promedio_max: maxIrradiacion,\n  irradiacion_promedio_anual: promedioAnual\n};"
      },
      "name": "Calculate Annual Irradiation",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        3248,
        1044
      ],
      "id": "e3fc73c4-b0e3-49d9-8b85-c209a7791a62",
      "notes": "REEMPLAZA a 'Process NASA Data' - Procesa respuesta de NASA API"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- INSERT COMPLETO - Todos los campos integrados\nINSERT INTO irradiacion_cache (\n  lat_grid,\n  lng_grid,\n  radio_km,\n  datos_nasa_mensuales,\n  irradiacion_promedio_min,\n  irradiacion_promedio_max,\n  irradiacion_promedio_anual,\n  fecha_obtencion,\n  vigente_hasta,\n  hash_ubicacion,\n  region_nombre\n) VALUES (\n  {{ $node[\"Generate Cache Key\"].json.lat_grid }},\n  {{ $node[\"Generate Cache Key\"].json.lng_grid }},\n  {{ $node[\"Generate Cache Key\"].json.radio_km }},\n  '{{ JSON.stringify($node[\"Calculate Annual Irradiation\"].json.datos_nasa_mensuales) }}'::jsonb,\n  {{ $node[\"Calculate Annual Irradiation\"].json.irradiacion_promedio_min }},\n  {{ $node[\"Calculate Annual Irradiation\"].json.irradiacion_promedio_max }},\n  {{ $node[\"Calculate Annual Irradiation\"].json.irradiacion_promedio_anual }},\n  NOW(),\n  NOW() + INTERVAL '6 months',\n  '{{ $node[\"Generate Cache Key\"].json.hash_ubicacion }}',\n  '{{ \n    $node[\"Google Geocoding API\"].json.results[0].address_components\n      .filter(component => component.types.includes(\"administrative_area_level_1\"))[0]\n      ?.long_name || \"Estado no encontrado\"\n  }}'\n)\nRETURNING id, hash_ubicacion;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        3472,
        1044
      ],
      "id": "e171c203-cbc8-4023-bf18-4238f22d711a",
      "name": "Save to NASA Cache",
      "credentials": {
        "postgres": {
          "id": "jjHxTq8OTwLBl895",
          "name": "Postgres account supabase enerbook"
        }
      },
      "notes": "Guarda datos NASA en caché para futuras consultas"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3920,
        852
      ],
      "id": "f6248bf3-7b15-437f-bb61-10fa50b1a268",
      "name": "Merge Cached and New Data",
      "notes": "Une rama de caché (TRUE) con rama nueva (FALSE)"
    },
    {
      "parameters": {
        "jsCode": "// Usar datos desde caché cuando existe\nconst cacheData = $input.all()[0].json;\n\nconsole.log('Using cached NASA data');\nconsole.log('Cache hash:', cacheData.hash_ubicacion);\n\nreturn [{\n  json: {\n    datos_nasa_mensuales: cacheData.datos_nasa_mensuales,\n    irradiacion_promedio_min: cacheData.irradiacion_promedio_min,\n    irradiacion_promedio_max: cacheData.irradiacion_promedio_max,\n    irradiacion_promedio_anual: cacheData.irradiacion_promedio_anual,\n    cache_saved: false,  // No se guardó, se usó existente\n    cache_id: cacheData.id,\n    hash_ubicacion: cacheData.hash_ubicacion,\n    temp_lead_id: 'unknown'  // Se actualizará en nodos posteriores\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3696,
        852
      ],
      "id": "671152f7-e688-4b94-8256-ceb8b780989d",
      "name": "Use Cached Data"
    },
    {
      "parameters": {
        "text": "={\n  \"role\": \"Extractor Especializado de Recibos CFE\",\n  \"description\": \"Extrae información completa de recibos de la Comisión Federal de Electricidad (CFE) de México. Devuelve ÚNICAMENTE JSON válido sin explicaciones adicionales.\",\n  \"input_data\": \"{{ $json.pages[0].markdown }}\",\n  \"instrucciones\": \"Lee TODO el texto completo antes de extraer. NO cortes información parcial - extrae campos completos. Si un campo no existe, usa null. El resultado debe ser SOLO JSON válido, sin markdown, sin bloques de código, sin explicaciones.\",\n  \"campos_a_extraer\": {\n    \"no_servicio\": \"Busca 'NO. DE SERVICIO:' y extrae el número completo (generalmente 12 dígitos). Ejemplo: 219890418432\",\n    \"RMU\": \"Busca 'RMU:' y extrae el código completo incluyendo números, guiones y texto (incluye TODO hasta el siguiente campo). Ejemplo: 72270 89-04-01 XAXX-010101 061 CFE\",\n    \"cuenta\": \"Busca 'CUENTA:' o 'CFE CUENTA:' y extrae el código alfanumérico completo (generalmente 16 caracteres). Ejemplo: 12DV08C011231540\",\n    \"tarifa\": \"Busca 'TARIFA:' y extrae el código (puede ser numérico como 01 o alfanumérico como GDMTH). Ejemplo: 01\",\n    \"no_medidor\": \"Busca 'NO. MEDIDOR:' o 'NO MEDIDOR:' y extrae el identificador completo. Ejemplo: 0B48J7\",\n    \"multiplicador\": \"Busca 'MULTIPLICADOR:' y extrae el número. Ejemplo: 1\",\n    \"no_hilos\": \"Busca 'NO HILOS:' o 'NO. HILOS:' y extrae el número (generalmente 1, 2 o 3). Ejemplo: 1\",\n    \"nombre\": \"Busca el nombre del cliente al inicio del recibo, antes de la dirección (generalmente en MAYÚSCULAS después del logo CFE). Ejemplo: FELIPE CARRANZA R\",\n    \"direccion\": \"Extrae la dirección COMPLETA del cliente tal como aparece en el recibo, sin modificar. Incluye calle, número, colonia, código postal, ciudad y estado. Ejemplo: 42 NTE 2207 PROLG 22 PINO SUAREZ Y BLVD XONACA DIEZ DE MAYO 08JC.P.72270 PUEBLA,PUE.\",\n    \"direccion_formatted\": \"Reformatea la dirección: 1) Convierte a formato título (primera letra mayúscula). 2) Elimina referencias: NAVE, BODEGA, LOCAL, DEPTO, OFICINA, PISO, INTERIOR + números. 3) Estandariza: AV/AVE a Av., CALLE a Calle, BLVD a Blvd., COL a Col., FRACC a Fracc. 4) Convierte estados: PUE a Puebla, QRO a Querétaro, CDMX/DF a Ciudad de México. 5) Agrega ', México' al final. Formato: 'Calle Número, Colonia, CP Ciudad, Estado, México'\",\n    \"periodo_inicio\": \"Busca 'PERIODO FACTURADO:' y extrae la primera fecha. Convierte del formato 'DD MES AA' (ejemplo: 07 ABR 25) al formato ISO 8601 'YYYY-MM-DD' (ejemplo: 2025-04-07). Meses: ENE=01, FEB=02, MAR=03, ABR=04, MAY=05, JUN=06, JUL=07, AGO=08, SEP=09, OCT=10, NOV=11, DIC=12. Año: 25=2025, 24=2024.\",\n    \"periodo_fin\": \"Busca 'PERIODO FACTURADO:' y extrae la segunda fecha (después del guión o 'al'). Convierte del formato 'DD MES AA' (ejemplo: 06 JUN 25) al formato ISO 8601 'YYYY-MM-DD' (ejemplo: 2025-06-06).\",\n    \"kwh_total\": \"Busca en la tabla de consumo 'Energía (kWh)' la columna 'Total período' y suma TODOS los valores de kWh (Básico + Intermedio + Excedente). Devuelve como número entero sin decimales ni comas. Ejemplo: si Básico=150 e Intermedio=27, entonces 177\",\n    \"total_pagar_mxn\": \"Busca el monto total a pagar (aparece como 'TOTAL A PAGAR:' o 'Total' en tabla de desglose con símbolo $). Elimina símbolos de moneda y comas, convierte a número decimal con punto y 2 decimales. Ejemplo: $242 = 242.00 o 242.56 = 242.56\"\n  },\n  \"validaciones\": \"Verifica que no_servicio tenga al menos 10 dígitos, que cuenta sea alfanumérico, que fechas estén en formato YYYY-MM-DD, que kwh_total y total_pagar_mxn sean numéricos. Si algún campo no se encuentra, asigna null.\",\n  \"ejemplo_salida\": {\n    \"no_servicio\": \"219890418432\",\n    \"RMU\": \"72270 89-04-01 XAXX-010101 061 CFE\",\n    \"cuenta\": \"12DV08C011231540\",\n    \"tarifa\": \"01\",\n    \"no_medidor\": \"0B48J7\",\n    \"multiplicador\": \"1\",\n    \"no_hilos\": \"1\",\n    \"nombre\": \"FELIPE CARRANZA R\",\n    \"direccion\": \"42 NTE 2207 PROLG 22 PINO SUAREZ Y BLVD XONACA DIEZ DE MAYO 08JC.P.72270 PUEBLA,PUE.\",\n    \"direccion_formatted\": \"Calle 42 Nte 2207, Col. Pino Suárez y Blvd Xonaca, 72270 Puebla, Puebla, México\",\n    \"periodo_inicio\": \"2025-04-07\",\n    \"periodo_fin\": \"2025-06-06\",\n    \"kwh_total\": \"177\",\n    \"total_pagar_mxn\": \"242.00\"\n  },\n  \"formato_respuesta\": \"Devuelve ÚNICAMENTE el JSON con los datos extraídos, sin explicaciones, sin markdown, sin bloques de código.\"\n}",
        "schemaType": "fromJson",
        "jsonSchemaExample": "{\n  \"no_servicio\": \"219890418432\",\n  \"RMU\": \"72270 89-04-01 XAXX-010101 061 CFE\",\n  \"cuenta\": \"12DV08C011231540\",\n  \"tarifa\": \"01\",\n  \"no_medidor\": \"0B48J7\",\n  \"multiplicador\": \"1\",\n  \"no_hilos\": \"1\",\n  \"nombre\": \"FELIPE CARRANZA R\",\n  \"direccion\": \"42 NTE 2207 PROLG 22 PINO SUAREZ Y BLVD XONACA DIEZ DE MAYO 08JC.P.72270 PUEBLA,PUE.\",\n  \"direccion_formatted\": \"Calle 42 Nte 2207, Col. Pino Suárez y Blvd Xonaca, 72270 Puebla, Puebla, México\",\n  \"periodo_inicio\": \"2025-04-07\",\n  \"periodo_fin\": \"2025-06-06\",\n  \"kwh_total\": \"177\",\n  \"total_pagar_mxn\": \"242.00\"\n}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.informationExtractor",
      "typeVersion": 1.2,
      "position": [
        656,
        624
      ],
      "id": "f5fd040f-a2d6-4866-a163-6d0124b24b58",
      "name": "datos_recibo_frontal_cfe"
    },
    {
      "parameters": {
        "text": "={\n  \"prompt\": {\n    \"role\": \"Extractor de Datos de Factura CFE\",\n    \"description\": \"Extrae los datos de consumo mensual en kWh desde una tabla markdown de una factura CFE. La tabla contiene rangos de fechas de facturación que deben convertirse al período correcto.\",\n    \"input_data\": \"{{ $json.pages[0].markdown }}\",\n    \"rules\": [\n      {\n        \"rule\": \"CRÍTICO: Los períodos en la tabla aparecen como rangos de fechas (ej: 'del 07 AGO 24 al 08 OCT 24'). Debes extraer ÚNICAMENTE la FECHA FINAL del rango (segundo mes y año).\"\n      },\n      {\n        \"rule\": \"EJEMPLO: 'del 07 AGO 24 al 08 OCT 24' → el período es 'OCT24' (no AGO24)\"\n      },\n      {\n        \"rule\": \"EJEMPLO: 'del 07 FEB 25 al 07 ABR 25' → el período es 'ABR25' (no FEB25)\"\n      },\n      {\n        \"rule\": \"El formato del período debe ser SIEMPRE: 3 letras del mes en MAYÚSCULAS + 2 dígitos del año (ej: OCT24, ABR25, DIC23)\"\n      },\n      {\n        \"rule\": \"Los meses abreviados válidos son: ENE, FEB, MAR, ABR, MAY, JUN, JUL, AGO, SEP, OCT, NOV, DIC\"\n      },\n      {\n        \"rule\": \"Si el mes ya está abreviado en 3 letras (JUN, FEB, DIC, AGO, OCT, ABR), manténlo tal cual\"\n      },\n      {\n        \"rule\": \"El año debe ser de 2 dígitos: 23, 24, 25, etc.\"\n      },\n      {\n        \"rule\": \"Extrae el consumo en kWh de la columna correspondiente como número entero\"\n      },\n      {\n        \"rule\": \"Si el consumo contiene comas (ej: 42,842), elimínalas para obtener el número entero (42842)\"\n      },\n      {\n        \"rule\": \"Ignora las columnas de 'Importe', 'Pagos' y 'Pendientes de Pago'\"\n      },\n      {\n        \"rule\": \"Elimina cualquier símbolo de moneda ($) y puntos decimales del consumo\"\n      },\n      {\n        \"rule\": \"Calcula 'consumo_max' como el valor máximo de kWh entre todos los períodos extraídos\"\n      },\n      {\n        \"rule\": \"NO incluyas encabezados, totales, promedios o filas sin datos válidos\"\n      },\n      {\n        \"rule\": \"Si una celda está vacía o no contiene datos numéricos de consumo, omite esa fila\"\n      },\n      {\n        \"rule\": \"NO inventes valores. Usa ÚNICAMENTE los datos presentes en la tabla\"\n      },\n      {\n        \"rule\": \"El orden de los elementos en 'consumo_historico' debe mantener el orden cronológico de la tabla (del más reciente al más antiguo o viceversa según aparezca)\"\n      },\n      {\n        \"rule\": \"CRÍTICO: El resultado debe ser ÚNICAMENTE un objeto JSON válido, sin texto adicional, sin explicaciones, sin markdown, sin bloques de código. Solo el JSON puro.\"\n      }\n    ],\n    \"output_example\": {\n      \"consumo_historico\": [\n        {\"periodo\": \"ABR25\", \"kwh\": 198},\n        {\"periodo\": \"FEB25\", \"kwh\": 196},\n        {\"periodo\": \"DIC24\", \"kwh\": 183},\n        {\"periodo\": \"OCT24\", \"kwh\": 204},\n        {\"periodo\": \"AGO24\", \"kwh\": 192},\n        {\"periodo\": \"JUN24\", \"kwh\": 223},\n        {\"periodo\": \"ABR24\", \"kwh\": 200},\n        {\"periodo\": \"FEB24\", \"kwh\": 193},\n        {\"periodo\": \"DIC23\", \"kwh\": 247},\n        {\"periodo\": \"OCT23\", \"kwh\": 268},\n        {\"periodo\": \"AGO23\", \"kwh\": 268}\n      ],\n      \"consumo_max\": 268\n    },\n    \"response_format\": \"JSON\",\n    \"validation\": {\n      \"check\": \"Verifica que cada período extraído corresponda a la FECHA FINAL del rango mostrado en la tabla\",\n      \"example_correct\": \"'del 07 JUN 24 al 07 AGO 24' → AGO24 ✓\",\n      \"example_wrong\": \"'del 07 JUN 24 al 07 AGO 24' → JUN24 ✗\"\n    }\n  }\n}",
        "schemaType": "fromJson",
        "jsonSchemaExample": "{\n  \"consumo_historico\": [{\n    \"periodo\": \"\",\n    \"kwh\": 0\n  }],\n  \"consumo_max\": 0\n}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.informationExtractor",
      "typeVersion": 1.2,
      "position": [
        656,
        1024
      ],
      "id": "43bae306-5603-4f4e-94c8-690e5e9fe868",
      "name": "datos_recibo_posterior_cfe1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO cotizaciones_inicial (\n  usuarios_id,\n  recibo_cfe,\n  consumo_kwh_historico,\n  resumen_energetico,\n  sizing_results,\n  irradiacion_cache_id\n) VALUES (\n  '{{ $json.user_id }}',\n  '{{ JSON.stringify($node[\"Combine Data\"].json || {}) }}'::jsonb,\n  '{{ JSON.stringify($node[\"Combine Data\"].json.consumo_historico || []) }}'::jsonb,\n  '{{ JSON.stringify({\n    consumo_max: $node[\"Combine Data\"].json.consumo_max || null,\n    consumo_promedio: Math.round(($node[\"Combine Data\"].json.consumo_historico || []).reduce((sum, item) => sum + item.kwh, 0) / ($node[\"Combine Data\"].json.consumo_historico?.length || 1)),\n    periodos_analizados: $node[\"Combine Data\"].json.consumo_historico?.length || 0\n  }) }}'::jsonb,\n  '{{ JSON.stringify($json.sizing_results || {}) }}'::jsonb,\n  {{ ($json.cache_id || $json.id) ? \"'\" + ($json.cache_id || $json.id) + \"'\" : 'NULL' }}\n) RETURNING id, usuarios_id",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        5168,
        852
      ],
      "id": "9f4809b3-29a6-4c6a-b22b-ce3d5c4e76f0",
      "name": "Save Initial Quotation",
      "credentials": {
        "postgres": {
          "id": "jjHxTq8OTwLBl895",
          "name": "Postgres account supabase enerbook"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ocr-nuevo-proyecto",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1360,
        876
      ],
      "id": "ee6fc82e-cf5c-4116-9569-e82d500663b5",
      "name": "Input",
      "webhookId": "cf3963cf-fb09-42f1-9ad3-a7954dfa5d0a"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/files",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "purpose",
              "value": "ocr"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "imagen_1"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -688,
        780
      ],
      "id": "537ea64b-a4e1-4249-bdab-3340a00af5d5",
      "name": "Upload Image",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "url": "=https://api.mistral.ai/v1/files/{{ $json.id }}/url",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "expiry",
              "value": "24"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -464,
        780
      ],
      "id": "4f7d4d62-54ce-480e-8f03-6919f7846b47",
      "name": "HTTP Request",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/ocr",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"mistral-ocr-latest\",\n  \"document\": {\n    \"type\": \"document_url\",\n    \"document_url\": \"{{ $json.url }}\"\n  },\n  \"include_image_base64\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -240,
        780
      ],
      "id": "24107749-2c38-4aaa-879b-14fadf7adefa",
      "name": "OCR Generic",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "url": "=https://api.mistral.ai/v1/files/{{ $json.id }}/url",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "expiry",
              "value": "24"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -464,
        972
      ],
      "id": "87c89a5a-435b-4bbf-9ddd-b7669d4beeaa",
      "name": "HTTP Request 2",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1008,
        876
      ],
      "id": "d0e0cb29-171f-42a4-b42a-8d8172a3f49f",
      "name": "Merge"
    },
    {
      "parameters": {
        "functionCode": "// Hash de ubicación para caché NASA\nconst lat = $json.latitude || 0;\nconst lng = $json.longitude || 0;\nconst radioKm = 5;\n\n// Verificar coordenadas válidas\nif (!lat || !lng) {\n  throw new Error('No se encontraron coordenadas válidas. Latitude: ' + lat + ', Longitude: ' + lng);\n}\n\n// Grid redondeado para optimizar caché (2 decimales)\nconst latGrid = Math.round(lat * 100) / 100;\nconst lngGrid = Math.round(lng * 100) / 100;\n\n// Hash simple pero efectivo\nfunction createLocationHash(lat, lng) {\n  const str = `${lat},${lng}`;\n  let hash = 0;\n  \n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  \n  return Math.abs(hash).toString(36);\n}\n\nconst hashUbicacion = createLocationHash(latGrid, lngGrid);\n\nreturn [{\n  json: {\n    latitude: lat,\n    longitude: lng,\n    lat_grid: latGrid,\n    lng_grid: lngGrid,\n    radio_km: radioKm,\n    hash_ubicacion: hashUbicacion\n  }\n}];"
      },
      "name": "Generate Cache Key",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2352,
        948
      ],
      "id": "f1282320-9d1c-409e-a6e0-3ecabdb19da9",
      "notes": "Genera hash_ubicacion para sistema de caché"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $json.hash_ubicacion }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "b5511f66-8533-431d-bf76-6c5900451d46"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2800,
        948
      ],
      "id": "b786ffaa-4696-4390-a22d-8d9aa94c34e5",
      "name": "Cache Exists?",
      "notes": "Bifurcación: TRUE=usar caché, FALSE=llamar NASA API"
    },
    {
      "parameters": {
        "functionCode": "// Fusionar los datos de irradiación con la información de caché guardado\nconst irradiacionData = $node[\"Calculate Annual Irradiation\"].json;\nconst cacheInfo = $json || {};\n\n// Obtener temp_lead_id desde el nodo Split Images Generic donde se genera originalmente\nlet tempLeadId = 'unknown';\n\ntry {\n  // Acceder directamente al nodo Split Images Generic que propaga el temp_lead_id\n  const splitImagesItems = $node[\"Split Images Generic\"].json;\n  \n  if (Array.isArray(splitImagesItems) && splitImagesItems.length > 0) {\n    tempLeadId = splitImagesItems[0]?.temp_lead_id || 'unknown';\n  } else if (splitImagesItems && typeof splitImagesItems === 'object') {\n    tempLeadId = splitImagesItems.temp_lead_id || 'unknown';\n  }\n} catch (error) {\n  console.error('Error getting temp_lead_id from Split Images Generic:', error);\n  tempLeadId = 'lead_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n}\n\nconsole.log('Merge Cache Info - tempLeadId:', tempLeadId);\n\nreturn [{\n  json: {\n    ...irradiacionData,\n    cache_saved: true,\n    cache_id: cacheInfo.id,\n    hash_ubicacion: cacheInfo.hash_ubicacion,\n    temp_lead_id: tempLeadId\n  }\n}];"
      },
      "name": "Merge Cache Info",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        3696,
        1044
      ],
      "id": "99f449d4-390f-40cd-b844-c97692501785",
      "notes": "Combina datos NASA procesados con metadata de caché"
    },
    {
      "parameters": {
        "functionCode": "// Ensure Project Data - VERSION CLIENTES\n// Asegura que user_id y datos del proyecto se propaguen correctamente\n\nconst item = items[0];\n\n// ============================================\n// 1. EXTRAER Y VALIDAR user_id (OBLIGATORIO)\n// ============================================\nlet userId = null;\n\n// Primero intentar desde el item actual\nif (item.json.user_id) {\n  userId = item.json.user_id;\n}\n\n// Si no está, buscar en el nodo Split Images Generic\nif (!userId) {\n  try {\n    const splitImagesData = $node['Split Images Generic'].json;\n    if (Array.isArray(splitImagesData) && splitImagesData.length > 0) {\n      userId = userId || splitImagesData[0].user_id;\n    } else if (splitImagesData && typeof splitImagesData === 'object') {\n      userId = userId || splitImagesData.user_id;\n    }\n  } catch (error) {\n    console.log('Could not access Split Images Generic data:', error.message);\n  }\n}\n\n// VALIDACIÓN CRÍTICA: user_id es OBLIGATORIO para clientes\nif (!userId) {\n  throw new Error('user_id is required in Ensure Project Data - workflow integrity error');\n}\n\nconsole.log('Ensure Project Data - user_id:', userId);\n\n// ============================================\n// 2. EXTRAER DATOS DEL PROYECTO\n// ============================================\nlet projectTitle = item.json.project_title || null;\nlet projectDescription = item.json.project_description || null;\n\n// Si no están en el item actual, buscar en Split Images Generic\nif (!projectTitle || !projectDescription) {\n  try {\n    const splitImagesData = $node['Split Images Generic'].json;\n    if (Array.isArray(splitImagesData) && splitImagesData.length > 0) {\n      projectTitle = projectTitle || splitImagesData[0].project_title || 'Proyecto Solar';\n      projectDescription = projectDescription || splitImagesData[0].project_description || '';\n    } else if (splitImagesData && typeof splitImagesData === 'object') {\n      projectTitle = projectTitle || splitImagesData.project_title || 'Proyecto Solar';\n      projectDescription = projectDescription || splitImagesData.project_description || '';\n    }\n  } catch (error) {\n    console.log('Could not access Split Images Generic data for project info:', error.message);\n  }\n}\n\n// Fallback final\nprojectTitle = projectTitle || 'Proyecto Solar';\nprojectDescription = projectDescription || '';\n\nconsole.log('Ensure Project Data - project_title:', projectTitle);\nconsole.log('Ensure Project Data - project_description:', projectDescription);\n\n// ============================================\n// 3. RETORNAR CON DATOS COMPLETOS\n// ============================================\nreturn [{\n  json: {\n    ...item.json,\n    user_id: userId,                       // CRÍTICO: user_id propagado\n    project_title: projectTitle,\n    project_description: projectDescription\n  },\n  binary: item.binary\n}];"
      },
      "name": "Ensure Project Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        4144,
        852
      ],
      "id": "5c0e0561-b196-47ec-b2cc-028a2c1a9b70"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO proyectos (\n  titulo,\n  descripcion,\n  estado,\n  usuarios_id,\n  cotizaciones_inicial_id,\n  fecha_limite\n) VALUES (\n  '{{ ($node[\"Parse AI Response and Merge\"].json.project_title || \"Proyecto Solar\").replace(/'/g, \"''\") }}',\n  '{{ ($node[\"Parse AI Response and Merge\"].json.project_description || \"\").replace(/'/g, \"''\") }}',\n  'abierto',\n  '{{ $node[\"Parse AI Response and Merge\"].json.user_id }}',\n  '{{ $node[\"Save Initial Quotation\"].json.id }}',\n  NOW() + INTERVAL '30 days'\n) RETURNING id, titulo, usuarios_id, cotizaciones_inicial_id",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        5392,
        852
      ],
      "id": "96580548-ab52-4762-bc7e-c77043147a8f",
      "name": "Create Project",
      "credentials": {
        "postgres": {
          "id": "jjHxTq8OTwLBl895",
          "name": "Postgres account supabase enerbook"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Restore User Context\n// Recupera user_id y datos del proyecto desde el webhook original\n// Este nodo va DESPUÉS de \"Merge\" y ANTES de \"Combine Data\"\n\n// ============================================\n// 1. OBTENER DATOS DEL WEBHOOK ORIGINAL\n// ============================================\nconst webhookInput = $('Input').item.json;\n\n// Extraer user_id del body (viene del webhook)\nlet userId = null;\n\nif (webhookInput.body && webhookInput.body.user_id) {\n  userId = webhookInput.body.user_id;\n} else if (webhookInput.body && webhookInput.body.userId) {\n  userId = webhookInput.body.userId;\n} else if (webhookInput.body && webhookInput.body.usuario_id) {\n  userId = webhookInput.body.usuario_id;\n}\n\n// Fallback: buscar en query o headers\nif (!userId && webhookInput.query && webhookInput.query.user_id) {\n  userId = webhookInput.query.user_id;\n}\n\nif (!userId && webhookInput.headers && webhookInput.headers['user-id']) {\n  userId = webhookInput.headers['user-id'];\n}\n\n// VALIDACIÓN CRÍTICA\nif (!userId) {\n  throw new Error('Could not restore user_id from webhook - received: ' + JSON.stringify(webhookInput));\n}\n\n// Extraer datos del proyecto\nconst projectTitle = (webhookInput.body && webhookInput.body.project_title) \n  || webhookInput.project_title \n  || 'Proyecto Solar';\n\nconst projectDescription = (webhookInput.body && webhookInput.body.project_description) \n  || webhookInput.project_description \n  || '';\n\nconsole.log('Restore User Context - user_id:', userId);\nconsole.log('Restore User Context - project_title:', projectTitle);\nconsole.log('Restore User Context - project_description:', projectDescription);\n\n// ============================================\n// 2. APLICAR CONTEXTO A TODOS LOS ITEMS\n// ============================================\nreturn items.map(item => {\n  console.log('Restoring context to item:', item.json.type || 'unknown');\n  \n  return {\n    json: {\n      ...item.json,\n      user_id: userId,\n      project_title: projectTitle,\n      project_description: projectDescription\n    },\n    binary: item.binary\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1232,
        876
      ],
      "id": "5e106d08-82f7-45af-96a8-bdde932b8fce",
      "name": "Restore User Context"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ \n  {\n    \"success\": true,\n    \"project_id\": $node[\"Create Project\"].json.id || \"unknown\",\n    \"message\": \"Proyecto creado exitosamente\",\n    \"redirect_url\": \"/dashboard?tab=proyectos\",\n    \"data\": {\n      \"consumo_max\": $json.output?.consumo_max || null,\n      \"sistema_requerido\": $json.sizing?.results?.kWp_needed || null,\n      \"paneles\": $json.sizing?.results?.n_panels || null,\n      \"produccion_anual\": $json.sizing?.results?.yearly_prod || null,\n      \"project_title\": $json.project_title || \"Proyecto Solar\"\n    }\n  }\n}}",
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        5616,
        852
      ],
      "id": "14c3e439-709f-4060-a790-f59533ff7c48",
      "name": "Response Success"
    },
    {
      "parameters": {
        "text": "=Eres un experto en energía solar. Genera un título y descripción para un proyecto fotovoltaico basado en estos datos:\n\nDATOS DEL PROYECTO:\n- Tarifa CFE: {{$json.tarifa}}\n- Consumo máximo histórico: {{$json.consumo_max}} kWh\n- Sistema requerido: {{$json.sizing_results.sistema.capacidad_sistema_kw}} kW\n- Número de paneles: {{$json.sizing_results.sistema.numero_paneles}}\n- Ciudad: {{$json.direccion_formatted}}\n- Irradiación promedio: {{$json.irradiacion_promedio_anual}} kWh/m²/día\n\nIMPORTANTE: \n- NO incluyas nombres de personas\n- NO incluyas direcciones completas, solo ciudad/estado\n- Usa los valores REALES del sistema calculado\n- El título debe ser genérico pero descriptivo\n\nGENERA:\n\nTítulo (máx 50 caracteres):\nFormato: \"Sistema Solar [kW REAL]kW - Tarifa [XX] [Ciudad]\"\n\nDescripción (máx 120 caracteres):\nMenciona: número de paneles REAL, consumo máximo, ciudad, irradiación\n\nFORMATO DE SALIDA (SOLO devuelve este JSON, nada más):\n{\n  \"titulo\": \"Sistema Solar 3.5kW - Tarifa 01 Puebla\",\n  \"descripcion\": \"Sistema de 7 paneles para 268 kWh/mes en Puebla con irradiación de 5.59 kWh/m²/día\"\n}",
        "schemaType": "fromJson",
        "jsonSchemaExample": "{\n  \"titulo\": \"Sistema Solar 3.5kW - Tarifa 01 Puebla\",\n  \"descripcion\": \"Sistema de 7 paneles para 268 kWh/mes en Puebla con irradiación de 5.59 kWh/m²/día\"\n}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.informationExtractor",
      "typeVersion": 1.2,
      "position": [
        4592,
        852
      ],
      "id": "06198855-b768-4f8a-9093-1e137242167a",
      "name": "Generate Project Info",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-20250514",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        4664,
        1076
      ],
      "id": "47a84cb6-d44c-44da-810d-e9c5bad8fc71",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "CoNkmjeMGzkDNaXN",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const aiOutput = $input.first().json.output;\nconst sizingData = $('Solar Sizing Calculator').first().json;\n\nif (!aiOutput || !sizingData) {\n  throw new Error('Faltan datos');\n}\n\n// Usar Object.assign en lugar de spread\nconst mergedData = Object.assign({}, sizingData, {\n  project_title: aiOutput.titulo,\n  project_description: aiOutput.descripcion\n});\n\nreturn [{ json: mergedData }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4944,
        852
      ],
      "id": "e8ce3933-b6b9-44e5-98f5-40594802262e",
      "name": "Parse AI Response and Merge"
    },
    {
      "parameters": {
        "url": "https://power.larc.nasa.gov/api/temporal/monthly/point",
        "options": {},
        "queryParametersUi": {
          "parameter": [
            {
              "name": "parameters",
              "value": "ALLSKY_SFC_SW_DWN"
            },
            {
              "name": "community",
              "value": "RE"
            },
            {
              "name": "latitude",
              "value": "={{ $('Generate Cache Key').item.json.latitude }}"
            },
            {
              "name": "longitude",
              "value": "={{ $('Generate Cache Key').item.json.longitude }}"
            },
            {
              "name": "start",
              "value": "2015"
            },
            {
              "name": "end",
              "value": "2024"
            },
            {
              "name": "format",
              "value": "JSON"
            }
          ]
        }
      },
      "name": "Get Annual Solar",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        3024,
        1044
      ],
      "id": "20ce1b5f-fc47-425d-83f5-9af1cbf58aa5"
    }
  ],
  "connections": {
    "Split Images Generic": {
      "main": [
        [
          {
            "node": "Route by Index",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Index": {
      "main": [
        [
          {
            "node": "Upload Image",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Upload Image 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Image 2": {
      "main": [
        [
          {
            "node": "HTTP Request 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Generic 2": {
      "main": [
        [
          {
            "node": "Merge OCR Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge OCR Results": {
      "main": [
        [
          {
            "node": "Content Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Classifier": {
      "main": [
        [
          {
            "node": "Route by Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Type": {
      "main": [
        [
          {
            "node": "datos_recibo_frontal_cfe",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "datos_recibo_posterior_cfe1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Data": {
      "main": [
        [
          {
            "node": "Google Geocoding API",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Cached and New Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Geocoding API": {
      "main": [
        [
          {
            "node": "Process Geocoding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Geocoding": {
      "main": [
        [
          {
            "node": "Set Location Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Solar Sizing Calculator": {
      "main": [
        [
          {
            "node": "Generate Project Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "datos_recibo_frontal_cfe",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "datos_recibo_posterior_cfe1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Set Location Data": {
      "main": [
        [
          {
            "node": "Generate Cache Key",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query NASA Cache": {
      "main": [
        [
          {
            "node": "Cache Exists?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Annual Irradiation": {
      "main": [
        [
          {
            "node": "Save to NASA Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to NASA Cache": {
      "main": [
        [
          {
            "node": "Merge Cache Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Cached and New Data": {
      "main": [
        [
          {
            "node": "Ensure Project Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached Data": {
      "main": [
        [
          {
            "node": "Merge Cached and New Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "datos_recibo_frontal_cfe": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "datos_recibo_posterior_cfe1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Save Initial Quotation": {
      "main": [
        [
          {
            "node": "Create Project",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input": {
      "main": [
        [
          {
            "node": "Split Images Generic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Image": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "OCR Generic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Generic": {
      "main": [
        [
          {
            "node": "Merge OCR Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request 2": {
      "main": [
        [
          {
            "node": "OCR Generic 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Restore User Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Cache Key": {
      "main": [
        [
          {
            "node": "Query NASA Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Exists?": {
      "main": [
        [
          {
            "node": "Use Cached Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Annual Solar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Cache Info": {
      "main": [
        [
          {
            "node": "Merge Cached and New Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Ensure Project Data": {
      "main": [
        [
          {
            "node": "Solar Sizing Calculator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Project": {
      "main": [
        [
          {
            "node": "Response Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore User Context": {
      "main": [
        [
          {
            "node": "Combine Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Project Info": {
      "main": [
        [
          {
            "node": "Parse AI Response and Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Generate Project Info",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response and Merge": {
      "main": [
        [
          {
            "node": "Save Initial Quotation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Annual Solar": {
      "main": [
        [
          {
            "node": "Calculate Annual Irradiation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "3dea49b7dd9b43976d38842c495efe40be7c7e03943c21cc3656ea0a8437e9d2"
  }
}