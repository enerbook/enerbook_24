{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ocr-input",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -5360,
        268
      ],
      "id": "7e7e8909-d05b-453e-afca-8a4ffe5ea95f",
      "name": "Input",
      "webhookId": "ac352058-a428-4e50-b361-d7d62480c7e7"
    },
    {
      "parameters": {
        "jsCode": "// Nueva logica OCR-first: crear items genericos sin asumir tipo\nconst items = [];\nconst inputItem = $input.all()[0];\nconst tempLeadId = `lead_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n// Propagamos temp_lead_id a todos los items generados\nconst binaryKeys = Object.keys(inputItem.binary || {});\n\nif (binaryKeys.length === 0) {\n  throw new Error('No se recibieron imÃ¡genes en la solicitud');\n}\n\n// Crear un item por cada imagen recibida\nbinaryKeys.forEach((key, index) => {\n  items.push({\n    json: { \n      temp_lead_id: tempLeadId,\n      index: index,\n      total_images: binaryKeys.length\n    },\n    binary: { \n      [`imagen_${index + 1}`]: inputItem.binary[key] \n    }\n  });\n});\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5136,
        268
      ],
      "id": "695b91b8-cba4-4037-b061-0b8c10dbebea",
      "name": "Split Images Generic"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{ $json.index }}",
        "looseTypeValidation": true
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -4912,
        268
      ],
      "id": "e44a1942-b755-4480-9db2-4649a1d73361",
      "name": "Route by Index"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/files",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "purpose",
              "value": "ocr"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "imagen_1"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4688,
        172
      ],
      "id": "d520d651-fba6-4d87-9356-af876178f764",
      "name": "Upload Image 1",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/files",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "purpose",
              "value": "ocr"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "imagen_2"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4688,
        364
      ],
      "id": "21ab9771-2485-491e-8c36-3591b6c14611",
      "name": "Upload Image 2",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/ocr",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"mistral-ocr-latest\",\n  \"document\": {\n    \"type\": \"document_url\",\n    \"document_url\": \"{{ $json.url }}\"\n  },\n  \"include_image_base64\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4240,
        172
      ],
      "id": "4fa419d9-e5e7-47ed-beb3-d87d0ac5acea",
      "name": "OCR Generic 1",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/ocr",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"mistral-ocr-latest\",\n  \"document\": {\n    \"type\": \"document_url\",\n    \"document_url\": \"{{ $json.url }}\"\n  },\n  \"include_image_base64\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4240,
        364
      ],
      "id": "2c8954a5-b431-4e20-8617-8d6bbdfd6d27",
      "name": "OCR Generic 2",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -4016,
        268
      ],
      "id": "165f830d-f4de-4add-9ee3-d57014b03788",
      "name": "Merge OCR Results"
    },
    {
      "parameters": {
        "jsCode": "// Clasificador inteligente basado en contenido extraido\nconst items = $input.all();\n\n// Extraer el texto OCR de ambas imagenes\nconst ocr1 = items[0].json.pages?.[0]?.markdown || '';\nconst ocr2 = items[1].json.pages?.[0]?.markdown || '';\n\n// Funcion para detectar si es frontal (datos del cliente)\nfunction isFrontal(text) {\n  const frontalIndicators = [\n    /NO\\.?\\s*DE\\s*SERVICIO/i,\n    /RMU\\s*:/i,\n    /CUENTA\\s*:/i,\n    /CFE\\s*CUENTA/i,\n    /TARIFA\\s*:/i,\n    /NO\\.?\\s*MEDIDOR/i,\n    /MULTIPLICADOR/i,\n    /NOMBRE\\s*:/i,\n    /DIRECCION\\s*:/i,\n    /TOTAL\\s+A\\s+PAGAR/i,\n    /AVISO\\s+RECIBO/i\n  ];\n  \n  let score = 0;\n  for (const pattern of frontalIndicators) {\n    if (pattern.test(text)) score++;\n  }\n  return score;\n}\n\n// Funcion para detectar si es posterior (tabla de consumos)\nfunction isPosterior(text) {\n  const posteriorIndicators = [\n    /CONSUMO\\s+HISTORICO/i,\n    /kWh.*PERIODO/i,\n    /HISTORICO\\s+DE\\s+CONSUMO/i,\n    /CONSUMOS\\s+MENSUALES/i,\n    /del\\s+\\d+\\s+\\w+\\s+\\d+\\s+al\\s+\\d+\\s+\\w+\\s+\\d+/i\n  ];\n  \n  // Contar patrones de fechas y numeros tipicos de tabla\n  const hasDateRanges = (text.match(/del\\s+\\d+\\s+\\w+\\s+\\d+\\s+al/gi) || []).length > 3;\n  const hasKwhNumbers = (text.match(/\\d{2,4}\\s*kWh/gi) || []).length > 3;\n  \n  let score = 0;\n  for (const pattern of posteriorIndicators) {\n    if (pattern.test(text)) score += 2;\n  }\n  if (hasDateRanges) score += 3;\n  if (hasKwhNumbers) score += 3;\n  \n  return score;\n}\n\n// Clasificar\nconst score1_frontal = isFrontal(ocr1);\nconst score1_posterior = isPosterior(ocr1);\nconst score2_frontal = isFrontal(ocr2);\nconst score2_posterior = isPosterior(ocr2);\n\nconsole.log('Scores:', {\n  image1: { frontal: score1_frontal, posterior: score1_posterior },\n  image2: { frontal: score2_frontal, posterior: score2_posterior }\n});\n\nlet frontalOcr, posteriorOcr;\n\nif (score1_frontal > score1_posterior && score2_posterior > score2_frontal) {\n  // Imagen 1 es frontal, Imagen 2 es posterior\n  frontalOcr = items[0].json;\n  posteriorOcr = items[1].json;\n} else if (score2_frontal > score2_posterior && score1_posterior > score1_frontal) {\n  // Imagen 2 es frontal, Imagen 1 es posterior\n  frontalOcr = items[1].json;\n  posteriorOcr = items[0].json;\n} else if (score1_frontal >= score2_frontal) {\n  // Por eliminacion, asignar imagen 1 como frontal\n  frontalOcr = items[0].json;\n  posteriorOcr = items[1].json;\n} else {\n  // Por eliminacion, asignar imagen 2 como frontal\n  frontalOcr = items[1].json;\n  posteriorOcr = items[0].json;\n}\n\n// Retornar items clasificados correctamente\nreturn [\n  {\n    json: {\n      ...frontalOcr,\n      type: 'frontal',\n      temp_lead_id: items[0].json.temp_lead_id\n    }\n  },\n  {\n    json: {\n      ...posteriorOcr,\n      type: 'posterior',\n      temp_lead_id: items[0].json.temp_lead_id\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3792,
        268
      ],
      "id": "e4334c4c-935d-48b9-a288-0ed9b45677b5",
      "name": "Content Classifier"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.type }}",
              "rightValue": "frontal",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3568,
        268
      ],
      "id": "87257d90-0d3a-4822-8372-1088194736cd",
      "name": "Route by Type"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -2992,
        268
      ],
      "id": "b1261374-2aca-40a0-a8e4-08d0d9e2258e",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "const frontal = $input.all()[0].json.output || $input.all()[0].json;\nconst posterior = $input.all()[1].json.output || $input.all()[1].json;\nconst tempLeadId = $input.all()[0].json.temp_lead_id || `lead_${Date.now()}`;\n\nreturn [{\n  json: {\n    ...frontal,\n    ...posterior,\n    temp_lead_id: tempLeadId\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2768,
        268
      ],
      "id": "66f5d34d-f154-469d-b272-0ccda4d71338",
      "name": "Combine Data"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://maps.googleapis.com/maps/api/geocode/json",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "address",
              "value": "={{ $json.direccion_formatted }}"
            },
            {
              "name": "key",
              "value": "AIzaSyBI6Vup5IKvfvlyvdhV_9nipF5FXaVnZ04"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2544,
        340
      ],
      "id": "2b511c96-4cdb-43ab-b608-aa70927d43e0",
      "name": "Google Geocoding API"
    },
    {
      "parameters": {
        "jsCode": "const geocodeResult = $input.all()[0].json;\n\nif (geocodeResult.results && geocodeResult.results.length > 0) {\n  const location = geocodeResult.results[0].geometry.location;\n  return [{\n    json: {\n      ...($node[\"Combine Data\"].json),\n      latitud: location.lat,\n      longitud: location.lng,\n      direccion_geocoded: geocodeResult.results[0].formatted_address\n    }\n  }];\n} else {\n  return [{\n    json: {\n      ...($node[\"Combine Data\"].json),\n      latitud: 19.0414,\n      longitud: -98.2063,\n      direccion_geocoded: \"Puebla, Mexico (default)\"\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2320,
        340
      ],
      "id": "71a2a820-6348-4e57-b276-fc09c736965c",
      "name": "Process Geocoding"
    },
    {
      "parameters": {
        "jsCode": "// Leer input\nconst data = $input.all()[0].json;\n\n// ParÃ¡metros del sistema\nconst PR = 0.80;\nconst oversizeFact = 1.05;\nconst DAYS_PER_MONTH = 30.4;\nconst panelWp = 550;\n\n// Inputs principales\nconst consumoMax = data.consumo_max || 250;\nconst irrDayAvg = parseFloat(data.nasa_irradiation?.annual_average) || 5.5;\n\n// CÃ¡lculos intermedios - Rendimientos especÃ­ficos\nconst specYieldDay = irrDayAvg * PR;\nconst specYieldMonth = specYieldDay * DAYS_PER_MONTH;\nconst specYieldAnnual = specYieldDay * 365;\n\n// CÃ¡lculos intermedios - Potencia requerida (mÃ©todo dual)\nconst consumoAnual = consumoMax * 12;\nconst kWpByYear = consumoAnual / specYieldAnnual;\nconst kWpByPeak = consumoMax / specYieldMonth;\nconst kWpNeededRaw = Math.max(kWpByYear, kWpByPeak);\nconst kWpNeeded = kWpNeededRaw * oversizeFact;\n\n// CÃ¡lculos de paneles\nconst nPanels = Math.ceil((kWpNeeded * 1000) / panelWp);\n\n// ProducciÃ³n anual\nconst produccionAnual = specYieldAnnual * kWpNeeded;\n\nreturn [{\n  json: {\n    ...data,\n    sizing_results: {\n      // === INPUTS ===\n      inputs: {\n        consumo_max_kwh: consumoMax,\n        irradiacion_promedio_kwh_m2_dia: irrDayAvg,\n        performance_ratio: PR,\n        factor_sobredimensionamiento: oversizeFact,\n        dias_por_mes: DAYS_PER_MONTH,\n        potencia_panel_wp: panelWp\n      },\n      \n      // === CÃLCULOS INTERMEDIOS ===\n      calculos_intermedios: {\n        rendimiento_especifico_diario: +specYieldDay.toFixed(2),\n        rendimiento_especifico_mensual: +specYieldMonth.toFixed(2),\n        rendimiento_especifico_anual: +specYieldAnnual.toFixed(2),\n        consumo_anual_kwh: consumoAnual,\n        kWp_por_metodo_anual: +kWpByYear.toFixed(2),\n        kWp_por_metodo_mensual: +kWpByPeak.toFixed(2),\n        kWp_necesario_sin_oversize: +kWpNeededRaw.toFixed(2)\n      },\n      \n      // === RESULTADOS FINALES ===\n      sistema: {\n        capacidad_sistema_kw: +kWpNeeded.toFixed(2),\n        numero_paneles: nPanels,\n        produccion_anual_kwh: Math.round(produccionAnual)\n      }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        244
      ],
      "id": "b3bd6e5f-6054-471b-a5a7-7ceba0aad2a2",
      "name": "Solar Sizing Calculator"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-3-haiku-20240307",
          "mode": "list",
          "cachedResultName": "Claude Haiku 3"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        -3272,
        240
      ],
      "id": "c12ac550-69bf-4675-8687-4023e47ca887",
      "name": "Anthropic Chat Model2",
      "credentials": {
        "anthropicApi": {
          "id": "CoNkmjeMGzkDNaXN",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "text": "={\n  \"role\": \"Extractor Especializado de Recibos CFE\",\n  \"description\": \"Extrae informaciÃ³n completa de recibos de la ComisiÃ³n Federal de Electricidad (CFE) de MÃ©xico. Devuelve ÃNICAMENTE JSON vÃ¡lido sin explicaciones adicionales.\",\n  \"input_data\": \"{{ $json.pages[0].markdown }}\",\n  \"instrucciones\": \"Lee TODO el texto completo antes de extraer. NO cortes informaciÃ³n parcial - extrae campos completos. Si un campo no existe, usa null. El resultado debe ser SOLO JSON vÃ¡lido, sin markdown, sin bloques de cÃ³digo, sin explicaciones.\",\n  \"campos_a_extraer\": {\n    \"no_servicio\": \"Busca 'NO. DE SERVICIO:' y extrae el nÃºmero completo (generalmente 12 dÃ­gitos). Ejemplo: 219890418432\",\n    \"RMU\": \"Busca 'RMU:' y extrae el cÃ³digo completo incluyendo nÃºmeros, guiones y texto (incluye TODO hasta el siguiente campo). Ejemplo: 72270 89-04-01 XAXX-010101 061 CFE\",\n    \"cuenta\": \"Busca 'CUENTA:' o 'CFE CUENTA:' y extrae el cÃ³digo alfanumÃ©rico completo (generalmente 16 caracteres). Ejemplo: 12DV08C011231540\",\n    \"tarifa\": \"Busca 'TARIFA:' y extrae el cÃ³digo (puede ser numÃ©rico como 01 o alfanumÃ©rico como GDMTH). Ejemplo: 01\",\n    \"no_medidor\": \"Busca 'NO. MEDIDOR:' o 'NO MEDIDOR:' y extrae el identificador completo. Ejemplo: 0B48J7\",\n    \"multiplicador\": \"Busca 'MULTIPLICADOR:' y extrae el nÃºmero. Ejemplo: 1\",\n    \"no_hilos\": \"Busca 'NO HILOS:' o 'NO. HILOS:' y extrae el nÃºmero (generalmente 1, 2 o 3). Ejemplo: 1\",\n    \"nombre\": \"Busca el nombre del cliente al inicio del recibo, antes de la direcciÃ³n (generalmente en MAYÃSCULAS despuÃ©s del logo CFE). Ejemplo: FELIPE CARRANZA R\",\n    \"direccion\": \"Extrae la direcciÃ³n COMPLETA del cliente tal como aparece en el recibo, sin modificar. Incluye calle, nÃºmero, colonia, cÃ³digo postal, ciudad y estado. Ejemplo: 42 NTE 2207 PROLG 22 PINO SUAREZ Y BLVD XONACA DIEZ DE MAYO 08JC.P.72270 PUEBLA,PUE.\",\n    \"direccion_formatted\": \"Reformatea la direcciÃ³n: 1) Convierte a formato tÃ­tulo (primera letra mayÃºscula). 2) Elimina referencias: NAVE, BODEGA, LOCAL, DEPTO, OFICINA, PISO, INTERIOR + nÃºmeros. 3) Estandariza: AV/AVE a Av., CALLE a Calle, BLVD a Blvd., COL a Col., FRACC a Fracc. 4) Convierte estados: PUE a Puebla, QRO a QuerÃ©taro, CDMX/DF a Ciudad de MÃ©xico. 5) Agrega ', MÃ©xico' al final. Formato: 'Calle NÃºmero, Colonia, CP Ciudad, Estado, MÃ©xico'\",\n    \"periodo_inicio\": \"Busca 'PERIODO FACTURADO:' y extrae la primera fecha. Convierte del formato 'DD MES AA' (ejemplo: 07 ABR 25) al formato ISO 8601 'YYYY-MM-DD' (ejemplo: 2025-04-07). Meses: ENE=01, FEB=02, MAR=03, ABR=04, MAY=05, JUN=06, JUL=07, AGO=08, SEP=09, OCT=10, NOV=11, DIC=12. AÃ±o: 25=2025, 24=2024.\",\n    \"periodo_fin\": \"Busca 'PERIODO FACTURADO:' y extrae la segunda fecha (despuÃ©s del guiÃ³n o 'al'). Convierte del formato 'DD MES AA' (ejemplo: 06 JUN 25) al formato ISO 8601 'YYYY-MM-DD' (ejemplo: 2025-06-06).\",\n    \"kwh_total\": \"Busca en la tabla de consumo 'EnergÃ­a (kWh)' la columna 'Total perÃ­odo' y suma TODOS los valores de kWh (BÃ¡sico + Intermedio + Excedente). Devuelve como nÃºmero entero sin decimales ni comas. Ejemplo: si BÃ¡sico=150 e Intermedio=27, entonces 177\",\n    \"total_pagar_mxn\": \"Busca el monto total a pagar (aparece como 'TOTAL A PAGAR:' o 'Total' en tabla de desglose con sÃ­mbolo $). Elimina sÃ­mbolos de moneda y comas, convierte a nÃºmero decimal con punto y 2 decimales. Ejemplo: $242 = 242.00 o 242.56 = 242.56\"\n  },\n  \"validaciones\": \"Verifica que no_servicio tenga al menos 10 dÃ­gitos, que cuenta sea alfanumÃ©rico, que fechas estÃ©n en formato YYYY-MM-DD, que kwh_total y total_pagar_mxn sean numÃ©ricos. Si algÃºn campo no se encuentra, asigna null.\",\n  \"ejemplo_salida\": {\n    \"no_servicio\": \"219890418432\",\n    \"RMU\": \"72270 89-04-01 XAXX-010101 061 CFE\",\n    \"cuenta\": \"12DV08C011231540\",\n    \"tarifa\": \"01\",\n    \"no_medidor\": \"0B48J7\",\n    \"multiplicador\": \"1\",\n    \"no_hilos\": \"1\",\n    \"nombre\": \"FELIPE CARRANZA R\",\n    \"direccion\": \"42 NTE 2207 PROLG 22 PINO SUAREZ Y BLVD XONACA DIEZ DE MAYO 08JC.P.72270 PUEBLA,PUE.\",\n    \"direccion_formatted\": \"Calle 42 Nte 2207, Col. Pino SuÃ¡rez y Blvd Xonaca, 72270 Puebla, Puebla, MÃ©xico\",\n    \"periodo_inicio\": \"2025-04-07\",\n    \"periodo_fin\": \"2025-06-06\",\n    \"kwh_total\": \"177\",\n    \"total_pagar_mxn\": \"242.00\"\n  },\n  \"formato_respuesta\": \"Devuelve ÃNICAMENTE el JSON con los datos extraÃ­dos, sin explicaciones, sin markdown, sin bloques de cÃ³digo.\"\n}",
        "schemaType": "fromJson",
        "jsonSchemaExample": "{\n  \"no_servicio\": \"219890418432\",\n  \"RMU\": \"72270 89-04-01 XAXX-010101 061 CFE\",\n  \"cuenta\": \"12DV08C011231540\",\n  \"tarifa\": \"01\",\n  \"no_medidor\": \"0B48J7\",\n  \"multiplicador\": \"1\",\n  \"no_hilos\": \"1\",\n  \"nombre\": \"FELIPE CARRANZA R\",\n  \"direccion\": \"42 NTE 2207 PROLG 22 PINO SUAREZ Y BLVD XONACA DIEZ DE MAYO 08JC.P.72270 PUEBLA,PUE.\",\n  \"direccion_formatted\": \"Calle 42 Nte 2207, Col. Pino SuÃ¡rez y Blvd Xonaca, 72270 Puebla, Puebla, MÃ©xico\",\n  \"periodo_inicio\": \"2025-04-07\",\n  \"periodo_fin\": \"2025-06-06\",\n  \"kwh_total\": \"177\",\n  \"total_pagar_mxn\": \"242.00\"\n}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.informationExtractor",
      "typeVersion": 1.2,
      "position": [
        -3344,
        16
      ],
      "id": "c19796f3-8c87-417a-9308-bec30ba89062",
      "name": "datos_recibo_frontal_cfe1"
    },
    {
      "parameters": {
        "text": "={\n  \"prompt\": {\n    \"role\": \"Extractor de Datos de Factura CFE\",\n    \"description\": \"Extrae los datos de consumo mensual en kWh desde una tabla markdown de una factura CFE. La tabla contiene rangos de fechas de facturaciÃ³n que deben convertirse al perÃ­odo correcto.\",\n    \"input_data\": \"{{ $json.pages[0].markdown }}\",\n    \"rules\": [\n      {\n        \"rule\": \"CRÃTICO: Los perÃ­odos en la tabla aparecen como rangos de fechas (ej: 'del 07 AGO 24 al 08 OCT 24'). Debes extraer ÃNICAMENTE la FECHA FINAL del rango (segundo mes y aÃ±o).\"\n      },\n      {\n        \"rule\": \"EJEMPLO: 'del 07 AGO 24 al 08 OCT 24' â el perÃ­odo es 'OCT24' (no AGO24)\"\n      },\n      {\n        \"rule\": \"EJEMPLO: 'del 07 FEB 25 al 07 ABR 25' â el perÃ­odo es 'ABR25' (no FEB25)\"\n      },\n      {\n        \"rule\": \"El formato del perÃ­odo debe ser SIEMPRE: 3 letras del mes en MAYÃSCULAS + 2 dÃ­gitos del aÃ±o (ej: OCT24, ABR25, DIC23)\"\n      },\n      {\n        \"rule\": \"Los meses abreviados vÃ¡lidos son: ENE, FEB, MAR, ABR, MAY, JUN, JUL, AGO, SEP, OCT, NOV, DIC\"\n      },\n      {\n        \"rule\": \"Si el mes ya estÃ¡ abreviado en 3 letras (JUN, FEB, DIC, AGO, OCT, ABR), mantÃ©nlo tal cual\"\n      },\n      {\n        \"rule\": \"El aÃ±o debe ser de 2 dÃ­gitos: 23, 24, 25, etc.\"\n      },\n      {\n        \"rule\": \"Extrae el consumo en kWh de la columna correspondiente como nÃºmero entero\"\n      },\n      {\n        \"rule\": \"Si el consumo contiene comas (ej: 42,842), elimÃ­nalas para obtener el nÃºmero entero (42842)\"\n      },\n      {\n        \"rule\": \"Ignora las columnas de 'Importe', 'Pagos' y 'Pendientes de Pago'\"\n      },\n      {\n        \"rule\": \"Elimina cualquier sÃ­mbolo de moneda ($) y puntos decimales del consumo\"\n      },\n      {\n        \"rule\": \"Calcula 'consumo_max' como el valor mÃ¡ximo de kWh entre todos los perÃ­odos extraÃ­dos\"\n      },\n      {\n        \"rule\": \"NO incluyas encabezados, totales, promedios o filas sin datos vÃ¡lidos\"\n      },\n      {\n        \"rule\": \"Si una celda estÃ¡ vacÃ­a o no contiene datos numÃ©ricos de consumo, omite esa fila\"\n      },\n      {\n        \"rule\": \"NO inventes valores. Usa ÃNICAMENTE los datos presentes en la tabla\"\n      },\n      {\n        \"rule\": \"El orden de los elementos en 'consumo_historico' debe mantener el orden cronolÃ³gico de la tabla (del mÃ¡s reciente al mÃ¡s antiguo o viceversa segÃºn aparezca)\"\n      },\n      {\n        \"rule\": \"CRÃTICO: El resultado debe ser ÃNICAMENTE un objeto JSON vÃ¡lido, sin texto adicional, sin explicaciones, sin markdown, sin bloques de cÃ³digo. Solo el JSON puro.\"\n      }\n    ],\n    \"output_example\": {\n      \"consumo_historico\": [\n        {\"periodo\": \"ABR25\", \"kwh\": 198},\n        {\"periodo\": \"FEB25\", \"kwh\": 196},\n        {\"periodo\": \"DIC24\", \"kwh\": 183},\n        {\"periodo\": \"OCT24\", \"kwh\": 204},\n        {\"periodo\": \"AGO24\", \"kwh\": 192},\n        {\"periodo\": \"JUN24\", \"kwh\": 223},\n        {\"periodo\": \"ABR24\", \"kwh\": 200},\n        {\"periodo\": \"FEB24\", \"kwh\": 193},\n        {\"periodo\": \"DIC23\", \"kwh\": 247},\n        {\"periodo\": \"OCT23\", \"kwh\": 268},\n        {\"periodo\": \"AGO23\", \"kwh\": 268}\n      ],\n      \"consumo_max\": 268\n    },\n    \"response_format\": \"JSON\",\n    \"validation\": {\n      \"check\": \"Verifica que cada perÃ­odo extraÃ­do corresponda a la FECHA FINAL del rango mostrado en la tabla\",\n      \"example_correct\": \"'del 07 JUN 24 al 07 AGO 24' â AGO24 â\",\n      \"example_wrong\": \"'del 07 JUN 24 al 07 AGO 24' â JUN24 â\"\n    }\n  }\n}",
        "schemaType": "fromJson",
        "jsonSchemaExample": "{\n  \"consumo_historico\": [{\n    \"periodo\": \"\",\n    \"kwh\": 0\n  }],\n  \"consumo_max\": 0\n}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.informationExtractor",
      "typeVersion": 1.2,
      "position": [
        -3344,
        416
      ],
      "id": "158c2ff7-152c-4b80-a206-c7f03aa13e4e",
      "name": "datos_recibo_posterior_cfe"
    },
    {
      "parameters": {
        "url": "=https://api.mistral.ai/v1/files/{{ $json.id }}/url",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "expiry",
              "value": "24"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4464,
        172
      ],
      "id": "df0f6949-4c08-4ed8-b39b-6726e72b05fb",
      "name": "HTTP Request3",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "url": "=https://api.mistral.ai/v1/files/{{ $json.id }}/url",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "expiry",
              "value": "24"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4464,
        364
      ],
      "id": "09770b4e-01f2-472c-b0a2-226a6bd50b5f",
      "name": "HTTP Request4",
      "credentials": {
        "mistralCloudApi": {
          "id": "PSmKQQtzOTwdxGCi",
          "name": "Mistral Cloud account varac"
        }
      }
    },
    {
      "parameters": {
        "url": "https://power.larc.nasa.gov/api/temporal/monthly/point",
        "options": {},
        "queryParametersUi": {
          "parameter": [
            {
              "name": "parameters",
              "value": "ALLSKY_SFC_SW_DWN"
            },
            {
              "name": "community",
              "value": "RE"
            },
            {
              "name": "latitude",
              "value": "={{ $('Generate Cache Key').item.json.latitude }}"
            },
            {
              "name": "longitude",
              "value": "={{ $('Generate Cache Key').item.json.longitude }}"
            },
            {
              "name": "start",
              "value": "2015"
            },
            {
              "name": "end",
              "value": "2024"
            },
            {
              "name": "format",
              "value": "JSON"
            }
          ]
        }
      },
      "name": "Get Annual Solar",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -1200,
        436
      ],
      "id": "a4d82a16-1f90-41d2-9d5f-3071df3b5dda"
    },
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "number": [
            {
              "name": "latitude",
              "value": "={{ $json.latitud }}"
            },
            {
              "name": "longitude",
              "value": "={{ $json.longitud }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Set Location Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        -2096,
        340
      ],
      "id": "1b29ef37-7c73-44ae-8dbd-2afa42752734",
      "notes": "INSERTAR DESPUÃS DE 'Process Geocoding'"
    },
    {
      "parameters": {
        "functionCode": "// Hash de ubicaciÃ³n para cachÃ© NASA\nconst lat = $json.latitude || 0;\nconst lng = $json.longitude || 0;\nconst radioKm = 5;\n\n// Verificar coordenadas vÃ¡lidas\nif (!lat || !lng) {\n  throw new Error('No se encontraron coordenadas vÃ¡lidas. Latitude: ' + lat + ', Longitude: ' + lng);\n}\n\n// Grid redondeado para optimizar cachÃ© (2 decimales)\nconst latGrid = Math.round(lat * 100) / 100;\nconst lngGrid = Math.round(lng * 100) / 100;\n\n// Hash simple pero efectivo\nfunction createLocationHash(lat, lng) {\n  const str = `${lat},${lng}`;\n  let hash = 0;\n  \n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  \n  return Math.abs(hash).toString(36);\n}\n\nconst hashUbicacion = createLocationHash(latGrid, lngGrid);\n\nreturn [{\n  json: {\n    latitude: lat,\n    longitude: lng,\n    lat_grid: latGrid,\n    lng_grid: lngGrid,\n    radio_km: radioKm,\n    hash_ubicacion: hashUbicacion\n  }\n}];"
      },
      "name": "Generate Cache Key",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -1872,
        340
      ],
      "id": "94abc462-9f9a-4038-8f7e-9c43ccbb6adc",
      "notes": "Genera hash_ubicacion para sistema de cachÃ©"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id,\n  datos_nasa_mensuales,\n  irradiacion_promedio_min,\n  irradiacion_promedio_max,\n  irradiacion_promedio_anual,\n  fecha_obtencion,\n  vigente_hasta,\n  hash_ubicacion\nFROM irradiacion_cache \nWHERE hash_ubicacion = '{{ $json.hash_ubicacion }}'\n  AND vigente_hasta > NOW()\nORDER BY created_at DESC \nLIMIT 1;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1648,
        340
      ],
      "id": "c0e98fe8-f88c-4188-b660-582c4e8447ad",
      "name": "Query NASA Cache",
      "alwaysOutputData": true,
      "executeOnce": false,
      "credentials": {
        "postgres": {
          "id": "jjHxTq8OTwLBl895",
          "name": "Postgres account supabase enerbook"
        }
      },
      "notes": "Busca en cachÃ© si ya existe irradiaciÃ³n para esta ubicaciÃ³n"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $json.hash_ubicacion }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "b5511f66-8533-431d-bf76-6c5900451d46"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1424,
        340
      ],
      "id": "9aa0791f-f487-4215-bf98-bc7f7b11520a",
      "name": "Cache Exists?",
      "notes": "BifurcaciÃ³n: TRUE=usar cachÃ©, FALSE=llamar NASA API"
    },
    {
      "parameters": {
        "functionCode": "const data = $json?.properties?.parameter?.ALLSKY_SFC_SW_DWN ?? {};\nconst keys = Object.keys(data);\n\nif (keys.length === 0) {\n  return {\n    datos_nasa_mensuales: {\n      irradiacion_promedio: [],\n      unidad_medida: \"kWh/mÂ²/dÃ­a\",\n      resumen: {\n        mejor_mes: null,\n        peor_mes: null\n      }\n    },\n    irradiacion_promedio_min: null,\n    irradiacion_promedio_max: null,\n    irradiacion_promedio_anual: null\n  };\n}\n\n// Mapeo de meses con orden para mantener secuencia correcta\nconst monthsMap = [\n  { numero: \"01\", nombre: \"Enero\",      orden: 1 },\n  { numero: \"02\", nombre: \"Febrero\",    orden: 2 },\n  { numero: \"03\", nombre: \"Marzo\",      orden: 3 },\n  { numero: \"04\", nombre: \"Abril\",      orden: 4 },\n  { numero: \"05\", nombre: \"Mayo\",       orden: 5 },\n  { numero: \"06\", nombre: \"Junio\",      orden: 6 },\n  { numero: \"07\", nombre: \"Julio\",      orden: 7 },\n  { numero: \"08\", nombre: \"Agosto\",     orden: 8 },\n  { numero: \"09\", nombre: \"Septiembre\", orden: 9 },\n  { numero: \"10\", nombre: \"Octubre\",    orden: 10 },\n  { numero: \"11\", nombre: \"Noviembre\",  orden: 11 },\n  { numero: \"12\", nombre: \"Diciembre\",  orden: 12 }\n];\n\n// Acumuladores\nconst sumPerMonth = {};\nconst countPerMonth = {};\nlet totalSum = 0;\nlet totalCount = 0;\n\n// Procesar datos - excluir mes 13 (promedios anuales)\nfor (const k of keys) {\n  const v = +data[k];\n  if (!Number.isFinite(v)) continue;\n  \n  const month = k.slice(4, 6); // YYYYMM...\n  \n  // Saltar mes 13 (promedios anuales en los datos originales)\n  if (month === \"13\") continue;\n  \n  if (!sumPerMonth[month]) {\n    sumPerMonth[month] = 0;\n    countPerMonth[month] = 0;\n  }\n  \n  sumPerMonth[month] += v;\n  countPerMonth[month] += 1;\n  totalSum += v;\n  totalCount += 1;\n}\n\n// Calcular promedio anual\nconst promedioAnual = totalCount > 0 ? +(totalSum / totalCount).toFixed(2) : null;\n\n// Crear array de irradiaciÃ³n promedio (ordenado por mes)\nconst irradiacionPromedio = monthsMap\n  .filter(m => m.numero in sumPerMonth) // Solo meses con datos\n  .map(m => {\n    const avg = sumPerMonth[m.numero] / countPerMonth[m.numero];\n    return {\n      mes: m.nombre,\n      irradiacion: +avg.toFixed(2),\n      orden: m.orden,\n      mes_numero: m.numero\n    };\n  })\n  .sort((a, b) => a.orden - b.orden); // Ordenar por mes natural\n\n// Calcular min y max de los promedios mensuales\nconst irradiacionValues = irradiacionPromedio.map(x => x.irradiacion);\nconst minIrradiacion = irradiacionValues.length > 0 ? Math.min(...irradiacionValues) : null;\nconst maxIrradiacion = irradiacionValues.length > 0 ? Math.max(...irradiacionValues) : null;\n\n// Estructura para datos_nasa_mensuales (JSONB) - formato simplificado\nconst datosNasaMensuales = {\n  irradiacion_promedio: irradiacionPromedio,\n  unidad_medida: \"kWh/mÂ²/dÃ­a\",\n  resumen: {\n    mejor_mes: irradiacionPromedio.length > 0 \n      ? irradiacionPromedio.reduce((max, curr) => \n          curr.irradiacion > max.irradiacion ? curr : max\n        ).mes \n      : null,\n    peor_mes: irradiacionPromedio.length > 0 \n      ? irradiacionPromedio.reduce((min, curr) => \n          curr.irradiacion < min.irradiacion ? curr : min\n        ).mes \n      : null\n  }\n};\n\n// Retornar objeto con los campos exactos para la base de datos\nreturn {\n  datos_nasa_mensuales: datosNasaMensuales,\n  irradiacion_promedio_min: minIrradiacion,\n  irradiacion_promedio_max: maxIrradiacion,\n  irradiacion_promedio_anual: promedioAnual\n};"
      },
      "name": "Calculate Annual Irradiation",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -976,
        436
      ],
      "id": "9473cba5-8db3-4116-858d-d6de814da53d",
      "notes": "REEMPLAZA a 'Process NASA Data' - Procesa respuesta de NASA API"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- INSERT COMPLETO - Todos los campos integrados\nINSERT INTO irradiacion_cache (\n  lat_grid,\n  lng_grid,\n  radio_km,\n  datos_nasa_mensuales,\n  irradiacion_promedio_min,\n  irradiacion_promedio_max,\n  irradiacion_promedio_anual,\n  fecha_obtencion,\n  vigente_hasta,\n  hash_ubicacion,\n  region_nombre\n) VALUES (\n  {{ $node[\"Generate Cache Key\"].json.lat_grid }},\n  {{ $node[\"Generate Cache Key\"].json.lng_grid }},\n  {{ $node[\"Generate Cache Key\"].json.radio_km }},\n  '{{ JSON.stringify($node[\"Calculate Annual Irradiation\"].json.datos_nasa_mensuales) }}'::jsonb,\n  {{ $node[\"Calculate Annual Irradiation\"].json.irradiacion_promedio_min }},\n  {{ $node[\"Calculate Annual Irradiation\"].json.irradiacion_promedio_max }},\n  {{ $node[\"Calculate Annual Irradiation\"].json.irradiacion_promedio_anual }},\n  NOW(),\n  NOW() + INTERVAL '6 months',\n  '{{ $node[\"Generate Cache Key\"].json.hash_ubicacion }}',\n  \n    '{{ \n    $node[\"Get Annual Solar\"].json.results[0].address_components\n      .filter(component => component.types.includes(\"administrative_area_level_1\"))[0]\n      ?.long_name || \"Estado no encontrado\"\n  }}'\n)\nRETURNING id, hash_ubicacion;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -752,
        436
      ],
      "id": "9ca8034f-1dbc-4d06-a319-21aa43e8125d",
      "name": "Save to NASA Cache",
      "credentials": {
        "postgres": {
          "id": "jjHxTq8OTwLBl895",
          "name": "Postgres account supabase enerbook"
        }
      },
      "notes": "Guarda datos NASA en cachÃ© para futuras consultas"
    },
    {
      "parameters": {
        "functionCode": "// Fusionar los datos de irradiaciÃ³n con la informaciÃ³n de cachÃ© guardado\nconst irradiacionData = $node[\"Calculate Annual Irradiation\"].json;\nconst cacheInfo = $json || {};\n\n// Obtener temp_lead_id desde el nodo Split Images Generic donde se genera originalmente\nlet tempLeadId = 'unknown';\n\ntry {\n  // Acceder directamente al nodo Split Images Generic que propaga el temp_lead_id\n  const splitImagesItems = $node[\"Split Images Generic\"].json;\n  \n  if (Array.isArray(splitImagesItems) && splitImagesItems.length > 0) {\n    tempLeadId = splitImagesItems[0]?.temp_lead_id || 'unknown';\n  } else if (splitImagesItems && typeof splitImagesItems === 'object') {\n    tempLeadId = splitImagesItems.temp_lead_id || 'unknown';\n  }\n} catch (error) {\n  console.error('Error getting temp_lead_id from Split Images Generic:', error);\n  tempLeadId = 'lead_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n}\n\nconsole.log('Merge Cache Info - tempLeadId:', tempLeadId);\n\nreturn [{\n  json: {\n    ...irradiacionData,\n    cache_saved: true,\n    cache_id: cacheInfo.id,\n    hash_ubicacion: cacheInfo.hash_ubicacion,\n    temp_lead_id: tempLeadId\n  }\n}];"
      },
      "name": "Merge Cache Info",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -528,
        436
      ],
      "id": "3cb28631-76e2-4639-abd1-c144c512a9c0",
      "notes": "Combina datos NASA procesados con metadata de cachÃ©"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -304,
        244
      ],
      "id": "d479403a-8b96-49e0-85ba-533d1d6de254",
      "name": "Merge Cached and New Data",
      "notes": "Une rama de cachÃ© (TRUE) con rama nueva (FALSE)"
    },
    {
      "parameters": {
        "functionCode": "// Asegurar que temp_lead_id se propague\nconst item = items[0];\n\n// Buscar temp_lead_id en varios lugares posibles\nlet tempLeadId = null;\n\n// Primero intentar desde el item actual\nif (item.json.temp_lead_id) {\n  tempLeadId = item.json.temp_lead_id;\n}\n\n// Si no estÃ¡, buscar en el nodo Split Images Generic\nif (!tempLeadId || tempLeadId === 'unknown') {\n  try {\n    const splitImagesData = $node['Split Images Generic'].json;\n    if (Array.isArray(splitImagesData) && splitImagesData.length > 0) {\n      tempLeadId = tempLeadId || splitImagesData[0].temp_lead_id;\n    } else if (splitImagesData && typeof splitImagesData === 'object') {\n      tempLeadId = tempLeadId || splitImagesData.temp_lead_id;\n    }\n  } catch (error) {\n    console.log('Could not access Split Images Generic data:', error.message);\n  }\n}\n\n// Si aÃºn no estÃ¡, generar uno nuevo\nif (!tempLeadId || tempLeadId === 'unknown') {\n  tempLeadId = 'lead_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n}\n\nconsole.log('Ensure Project Data - tempLeadId:', tempLeadId);\n\n// Asegurar que todos los datos se pasen con el temp_lead_id\nreturn [{\n  json: {\n    ...item.json,\n    temp_lead_id: tempLeadId\n  },\n  binary: item.binary\n}];"
      },
      "name": "Ensure Project Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -80,
        244
      ],
      "id": "5cd2c8ae-a313-40bd-a2f1-857d279e6ee9"
    },
    {
      "parameters": {
        "jsCode": "// Usar datos desde cachÃ© cuando existe\nconst cacheData = $input.all()[0].json;\n\nconsole.log('Using cached NASA data');\nconsole.log('Cache hash:', cacheData.hash_ubicacion);\n\nreturn [{\n  json: {\n    datos_nasa_mensuales: cacheData.datos_nasa_mensuales,\n    irradiacion_promedio_min: cacheData.irradiacion_promedio_min,\n    irradiacion_promedio_max: cacheData.irradiacion_promedio_max,\n    irradiacion_promedio_anual: cacheData.irradiacion_promedio_anual,\n    cache_saved: false,  // No se guardÃ³, se usÃ³ existente\n    cache_id: cacheData.id,\n    hash_ubicacion: cacheData.hash_ubicacion,\n    temp_lead_id: 'unknown'  // Se actualizarÃ¡ en nodos posteriores\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        244
      ],
      "id": "5bc0bd64-7a34-413f-b636-a201f6477357",
      "name": "Use Cached Data"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO cotizaciones_leads_temp (\n  temp_lead_id,\n  recibo_cfe,\n  consumo_kwh_historico,\n  resumen_energetico,\n  sizing_results,\n  irradiacion_cache_id\n) VALUES (\n  '{{ $json.temp_lead_id || \"unknown\" }}',\n  '{{ JSON.stringify($node[\"Combine Data\"].json || {}) }}'::jsonb,\n  '{{ JSON.stringify($node[\"Combine Data\"].json.consumo_historico || []) }}'::jsonb,\n  '{{ JSON.stringify({\n    consumo_max: $node[\"Combine Data\"].json.consumo_max || null,\n    consumo_promedio: Math.round(($node[\"Combine Data\"].json.consumo_historico || []).reduce((sum, item) => sum + item.kwh, 0) / ($node[\"Combine Data\"].json.consumo_historico?.length || 1)),\n    periodos_analizados: $node[\"Combine Data\"].json.consumo_historico?.length || 0\n  }) }}'::jsonb,\n  '{{ JSON.stringify($json.sizing_results || {}) }}'::jsonb,\n  {{ ($json.cache_id || $json.id) ? \"'\" + ($json.cache_id || $json.id) + \"'\" : 'NULL' }}\n) RETURNING id, temp_lead_id",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        368,
        244
      ],
      "id": "06f2f205-03f2-4074-91a2-23265cc3e907",
      "name": "Save Temp Quote",
      "credentials": {
        "postgres": {
          "id": "jjHxTq8OTwLBl895",
          "name": "Postgres account supabase enerbook"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ \n  {\n    \"success\": true,\n    \"temp_lead_id\": $node[\"Save Temp Quote\"].json.temp_lead_id || \"unknown\",\n    \"message\": \"AnÃ¡lisis energÃ©tico completado\",\n    \"redirect_url\": \"/dashboard?temp_lead_id=\" + ($node[\"Save Temp Quote\"].json.temp_lead_id || \"unknown\"),\n    \"data\": {\n      \"consumo_max\": $json.output?.consumo_max || null,\n      \"sistema_requerido\": $json.sizing?.results?.kWp_needed || null,\n      \"paneles\": $json.sizing?.results?.n_panels || null,\n      \"produccion_anual\": $json.sizing?.results?.yearly_prod || null\n    }\n  }\n}}",
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        592,
        244
      ],
      "id": "968d5cef-00a1-49bb-ab46-25e6a33815f1",
      "name": "Respond to Webhook"
    }
  ],
  "connections": {
    "Input": {
      "main": [
        [
          {
            "node": "Split Images Generic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Images Generic": {
      "main": [
        [
          {
            "node": "Route by Index",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Index": {
      "main": [
        [
          {
            "node": "Upload Image 1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Upload Image 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Image 1": {
      "main": [
        [
          {
            "node": "HTTP Request3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Image 2": {
      "main": [
        [
          {
            "node": "HTTP Request4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Generic 1": {
      "main": [
        [
          {
            "node": "Merge OCR Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Generic 2": {
      "main": [
        [
          {
            "node": "Merge OCR Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge OCR Results": {
      "main": [
        [
          {
            "node": "Content Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Classifier": {
      "main": [
        [
          {
            "node": "Route by Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Type": {
      "main": [
        [
          {
            "node": "datos_recibo_frontal_cfe1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "datos_recibo_posterior_cfe",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Combine Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Data": {
      "main": [
        [
          {
            "node": "Google Geocoding API",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Cached and New Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Geocoding API": {
      "main": [
        [
          {
            "node": "Process Geocoding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Geocoding": {
      "main": [
        [
          {
            "node": "Set Location Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Solar Sizing Calculator": {
      "main": [
        [
          {
            "node": "Save Temp Quote",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "datos_recibo_frontal_cfe1",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "datos_recibo_posterior_cfe",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "datos_recibo_frontal_cfe1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "datos_recibo_posterior_cfe": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "HTTP Request3": {
      "main": [
        [
          {
            "node": "OCR Generic 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request4": {
      "main": [
        [
          {
            "node": "OCR Generic 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Annual Solar": {
      "main": [
        [
          {
            "node": "Calculate Annual Irradiation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Location Data": {
      "main": [
        [
          {
            "node": "Generate Cache Key",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Cache Key": {
      "main": [
        [
          {
            "node": "Query NASA Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query NASA Cache": {
      "main": [
        [
          {
            "node": "Cache Exists?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Exists?": {
      "main": [
        [
          {
            "node": "Use Cached Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Annual Solar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Annual Irradiation": {
      "main": [
        [
          {
            "node": "Save to NASA Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to NASA Cache": {
      "main": [
        [
          {
            "node": "Merge Cache Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Cache Info": {
      "main": [
        [
          {
            "node": "Merge Cached and New Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Cached and New Data": {
      "main": [
        [
          {
            "node": "Ensure Project Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure Project Data": {
      "main": [
        [
          {
            "node": "Solar Sizing Calculator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached Data": {
      "main": [
        [
          {
            "node": "Merge Cached and New Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Save Temp Quote": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "3dea49b7dd9b43976d38842c495efe40be7c7e03943c21cc3656ea0a8437e9d2"
  }
}